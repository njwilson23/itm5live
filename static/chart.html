<html>

  <head>
    <title>79N ITM5LIVE</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.1/dist/leaflet.css" />
    <link rel="stylesheet" href="/static/chart.css">
    <link rel="stylesheet" href="/static/map.css">
    <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Aileron:300,400,700,300i">
  </head>

  <body>

    <style>
      .line {
        clip-path: url(#clip);
      }
    </style>

    <h1 class="center">79North Data Stream</h1>
    <p class="center"><em>August 23, 2016 &mdash; present</em></p>
    <div class="center" style="width: 70%; max-width: 40em;">

      <p>In August 2016, we deployed an ice-tethered mooring in sea ice near the floating ice tongue at 79North glacier. This mooring measure temperature and salinity in the ocean water beneath the floating ice tongue. This data will be important for understanding how ocean processes affect glacier behaviour.</p>

      <div id="mooringMap"></div>

      <p>The data are transmitted from the glacier daily, and are made available at 8 AM UTC via the plots and the links below. The charts may be scrolled or zoomed. Click legend items to highlight
        data.</p>

    </div>

    <div id="key" class="center">
      <div id="swatch150" class="active"><p>150 m</p></div>
      <div id="swatch250" class="active"><p>250 m</p></div>
      <div id="swatch350" class="active"><p>350 m</p></div>
      <div id="swatch500" class="active"><p>500 m</p></div>
      <br style="clear: left;">
    </div>
    <div id="axTemp" class="chart center"></div>
    <div id="axSal" class="chart center"></div>
    <div id="axPres" class="chart center"></div>

    <div class="center" style="width: 70%; max-width: 40em;">

      <p>All data are preliminary at this stage and provided without any
        guarantees regarding their accuracy or suitability for any purpose. The
        data used in the plots above may be downloaded from:<br>
        <div style="padding-left: 5em;">
          <a href="data/mc1.json">150 m Microcat</a><br>
          <a href="data/ad1.json">150 m Aquadopp</a><br><br>
          <a href="data/mc2.json">250 m Microcat</a><br>
          <a href="data/ad2.json">250 m Aquadopp</a><br><br>
          <a href="data/mc3.json">350 m Microcat</a><br>
          <a href="data/ad3.json">350 m Aquadopp</a><br><br>
          <a href="data/mc4.json">500 m Microcat</a><br>
          <a href="data/ad4.json">500 m Aquadopp</a>
        </div>
      </p>

      <p>Aquadopp plots coming soon.</p>

    </div>

    <script>
      var depths = [150, 250, 350, 500];
    
      for (var i=0; i!= depths.length; i++) {
        var depth = depths[i];
        document.getElementById("swatch"+depth).addEventListener("click", function(d) {
          return function(event) {
            var els = document.getElementsByClassName("depth"+d);
            var el;
            this.className = (this.className.includes("inactive")) ? "active" : "inactive";
            for (var i=0; i!=els.length; i++) {
              el = els[i];
              if (el.classList.contains("active")) {
                el.classList.remove("active");
                el.classList.add("inactive");
              } else {
                el.classList.remove("inactive");
                el.classList.add("active");
              }
            }
          }
        }(depth));
      }
    </script>

    <script src="https://unpkg.com/leaflet@1.0.1/dist/leaflet.js"></script>
    <script>
      var map = L.map('mooringMap').setView([79.67743,-20.39310], 3);

      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);

      // Get the data
      var request = new XMLHttpRequest();
      request.onreadystatechange = function() {
          if (request.readyState === XMLHttpRequest.DONE) {
              if (request.status == 200) {
                  positions = JSON.parse(request.responseText);
                  var point, lastpoint;
                  var options;
                  for (var i=0; i!=positions.length; i++) {
                      point = positions[i];
                      options = {
                          color: "blue",
                          fillOpacity: 0.3,
                          stroke: false,
                          radius: 2
                      }
                      if (i == positions.length-1) {
                          options.color = "red";
                          options.fillOpacity = 0.8;
                          options.radius = 5;
                      }
                      // Make a mark if it is the final point or it's in a different position than the previous point
                      if ((i == positions.length-1) || (lastpoint == null)
                          || ((point.longitude != lastpoint.longitude)
                          && (point.latitude != lastpoint.latitude))) {
                          L.circleMarker([point.latitude, point.longitude], options).addTo(map);
                      }
                      lastpoint = point;
                  }
                  var marker = L.marker([lastpoint.latitude, lastpoint.longitude]).addTo(map);
                  marker.bindPopup("<b>Last Position</b><br>"+lastpoint.longitude+", "+lastpoint.latitude);
              } else {
                  console.log("positions.json not found");
              }
          }
      };
      request.open("GET", "data/positions.json", true);
      request.send(null);
    </script>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="/static/chart.js"></script>
    <script>

      function parseDate(year, dayNumber) {
        var hour = Math.floor((dayNumber % 1) * 24);
        var minute = (((dayNumber % 1) * 24) % 1) * 60;
        return new Date(year, 0, Math.floor(dayNumber), hour, minute);
      }

      function convertData(row) {
        var name;
        for (name in row) {
          row[name] = +row[name];
        }
        row.date = parseDate(row.year, row.day);
        return row;
      }

      function convertDates(data) {
        data.forEach(function(d) {
          d.date = d3.isoParse(d.date);
        });
      }

      function filterNulls(d) {
        var k = Object.keys(d);
        for (var i=0; i!=k.length; i++) {
          if (d[k[i]] === null) {
            return false;
          }
        }
        return true;
      }

      var geom = {width: 600, height: 250,
                  margin: {top: 20, bottom: 50, left: 80, right: 20}};

      var axSal = createLineAxes(geom, "#axSal", "Salinity (psu)");
      var axTemp = createLineAxes(geom, "#axTemp", "Temperature (\u00b0C)");
      var axPres = createLineAxes(geom, "#axPres", "Pressure anomaly (dbar)");

      d3.json("/data/mc1.json", function(error, data) {
        if (error) throw error;
        data.forEach(function(d) {
          d.date = d3.isoParse(d.date);
        });
        data = data.filter(filterNulls);
        addLine(axTemp, data.map(function(d) {
          return {t: d.date, y: d.temperature};
        }), "depth150");
        addLine(axSal, data.map(function(d) {
          return {t: d.date, y: d.salinity};
        }), "depth150");
        var pAvg = d3.mean(data, function(d) {
          return d.pressure;
        });
        addLine(axPres, data.map(function(d) {
          return {t: d.date, y: d.pressure-pAvg};
        }), "depth150");
        rescaleAllLines(axTemp);
        rescaleAllLines(axSal);
        rescaleAllLines(axPres);
      });

      d3.json("/data/mc2.json", function(error, data) {
        if (error) throw error;
        data.forEach(function(d) {
          d.date = d3.isoParse(d.date);
        });
        data = data.filter(filterNulls);
        addLine(axTemp, data.map(function(d) {
          return {t: d.date, y: d.temperature};
        }), "depth250");
        addLine(axSal, data.map(function(d) {
          return {t: d.date, y: d.salinity};
        }), "depth250");
        var pAvg = d3.mean(data, function(d) {
          return d.pressure;
        });
        addLine(axPres, data.map(function(d) {
          return {t: d.date, y: d.pressure-pAvg};
        }), "depth250");
        rescaleAllLines(axTemp);
        rescaleAllLines(axSal);
        rescaleAllLines(axPres);
      });

      d3.json("/data/mc3.json", function(error, data) {
        if (error) throw error;
        data.forEach(function(d) {
          d.date = d3.isoParse(d.date);
        });
        data = data.filter(filterNulls);
        addLine(axTemp, data.map(function(d) {
          return {t: d.date, y: d.temperature};
        }), "depth350");
        addLine(axSal, data.map(function(d) {
          return {t: d.date, y: d.salinity};
        }), "depth350");
        var pAvg = d3.mean(data, function(d) {
          return d.pressure;
        });
        addLine(axPres, data.map(function(d) {
          return {t: d.date, y: d.pressure-pAvg};
        }), "depth350");
        rescaleAllLines(axTemp);
        rescaleAllLines(axSal);
        rescaleAllLines(axPres);
      });

      d3.json("/data/mc4.json", function(error, data) {
        if (error) throw error;
        data.forEach(function(d) {
          d.date = d3.isoParse(d.date);
        });
        data = data.filter(filterNulls);
        addLine(axTemp, data.map(function(d) {
          return {t: d.date, y: d.temperature};
        }), "depth500");
        addLine(axSal, data.map(function(d) {
          return {t: d.date, y: d.salinity};
        }), "depth500");
        var pAvg = d3.mean(data, function(d) {
          return d.pressure;
        });
        addLine(axPres, data.map(function(d) {
          return {t: d.date, y: d.pressure-pAvg};
        }), "depth500");
        rescaleAllLines(axTemp);
        rescaleAllLines(axSal);
        rescaleAllLines(axPres);
      });

      var zoom = d3.zoom()
        .scaleExtent([1, 20])
        .translateExtent([[0, 0], [geom.width, geom.height]])
        .extent([[0, 0], [geom.width, geom.height]])
        .duration(250)
        .on("zoom", zoomed);

      var axes = [axSal, axTemp, axPres];
      var zoomRect;
      for (var i=0; i!=axes.length; i++) {
        zoomRect = axes[i].zoomRect;
        zoomRect.call(zoom);
      }

    </script>

  </body>

</html>
